// -----// IR Dump Before MhloFusionPass ('builtin.func' operation: @main) //----- //
builtin.module  {
  builtin.func @main(%arg0: tensor<4x16xi32>, %arg1: tensor<4x16xi32>) -> tensor<2x4xi32> {
    %0 = mhlo.add %arg0, %arg1 {name = "add.3"} : tensor<4x16xi32>
    %1 = mhlo.subtract %0, %arg0 {name = "subtract.4"} : tensor<4x16xi32>
    %2 = "mhlo.slice"(%1) {limit_indices = dense<[2, 8]> : tensor<2xi64>, start_indices = dense<0> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} : (tensor<4x16xi32>) -> tensor<2x8xi32>
    %3 = mhlo.multiply %0, %1 {name = "multiply.5"} : tensor<4x16xi32>
    %4 = "mhlo.slice"(%3) {limit_indices = dense<[2, 8]> : tensor<2xi64>, start_indices = dense<0> : tensor<2xi64>, strides = dense<[1, 2]> : tensor<2xi64>} : (tensor<4x16xi32>) -> tensor<2x4xi32>
    return %4 : tensor<2x4xi32>
  }
}


loc("-":5:10): error: operand #0 does not dominate this use
// -----// IR Dump After MhloFusionPass Failed ('builtin.func' operation: @main) //----- //
"builtin.module"() ( {
  "builtin.func"() ( {
  ^bb0(%arg0: tensor<4x16xi32>, %arg1: tensor<4x16xi32>):  // no predecessors
    %0 = "mhlo.slice"(%1#0) {limit_indices = dense<[2, 8]> : tensor<2xi64>, start_indices = dense<0> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} : (tensor<4x16xi32>) -> tensor<2x8xi32>
    %1:2 = "mhlo.fusion"(%arg0, %arg1) ( {
      %3 = "mhlo.add"(%arg0, %arg1) {name = "add.3"} : (tensor<4x16xi32>, tensor<4x16xi32>) -> tensor<4x16xi32>
      %4 = "mhlo.subtract"(%3, %arg0) {name = "subtract.4"} : (tensor<4x16xi32>, tensor<4x16xi32>) -> tensor<4x16xi32>
      %5 = "mhlo.multiply"(%3, %4) {name = "multiply.5"} : (tensor<4x16xi32>, tensor<4x16xi32>) -> tensor<4x16xi32>
      "mhlo.return"(%4, %5) : (tensor<4x16xi32>, tensor<4x16xi32>) -> ()
    }) : (tensor<4x16xi32>, tensor<4x16xi32>) -> (tensor<4x16xi32>, tensor<4x16xi32>)
    %2 = "mhlo.slice"(%1#1) {limit_indices = dense<[2, 8]> : tensor<2xi64>, start_indices = dense<0> : tensor<2xi64>, strides = dense<[1, 2]> : tensor<2xi64>} : (tensor<4x16xi32>) -> tensor<2x4xi32>
    "std.return"(%2) : (tensor<2x4xi32>) -> ()
  }) {sym_name = "main", type = (tensor<4x16xi32>, tensor<4x16xi32>) -> tensor<2x4xi32>} : () -> ()
}) : () -> ()


loc("-":2:3): error: 'builtin.func' op unsupported module-level operation
mlir-hlo-run: /home/lipracer/work/mlir-hlo/tools/mlir-hlo-run/mlir-hlo-run.cpp:128: int main(int, char**): Assertion `maybeEngine && "failed to construct an execution engine"' failed.
